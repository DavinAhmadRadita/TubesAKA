import time
import tracemalloc
import heapq
from collections import deque
import random

def generate_grid(n, p_obstacle=0.2):
    """Generate n x n grid with random obstacles (1 = obstacle)."""
    grid = [[0 if random.random() > p_obstacle else 1 for _ in range(n)] for _ in range(n)]
    grid[0][0] = 0
    grid[n-1][n-1] = 0
    return grid

def neighbors(grid, x, y):
    for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:
        nx, ny = x + dx, y + dy
        if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 0:
            return True
    return False

def print_path(grid, path):
    for (x, y) in path:
        grid[x][y] = "*"
    for row in grid:
        print(" ".join(str(x) for x in row))
    print()

def bfs(grid, start, goal):
    queue = deque([start])
    visited = {start: None}
    while queue:
        x, y = queue.popleft()
        if (x, y) == goal:
            break
        for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:
            nx, ny = x+dx, y+dy
            if 0<=nx<len(grid) and 0<=ny<len(grid) and grid[nx][ny]==0 and (nx,ny) not in visited:
                visited[(nx,ny)] = (x,y)
                queue.append((nx,ny))
    return reconstruct_path(visited, goal)

def dfs(grid, start, goal):
    stack = [start]
    visited = {start: None}
    while stack:
        x, y = stack.pop()
        if (x, y) == goal:
            break
        for dx, dy in [(1,0),(0,1),(-1,0),(0,-1)]:
            nx, ny = x+dx, y+dy
            if 0<=nx<len(grid) and 0<=ny<len(grid) and grid[nx][ny]==0 and (nx,ny) not in visited:
                visited[(nx,ny)] = (x,y)
                stack.append((nx,ny))
    return reconstruct_path(visited, goal)

def dijkstra(grid, start, goal):
    dist = {start: 0}
    pq = [(0, start)]
    visited = {start: None}

    while pq:
        d, (x,y) = heapq.heappop(pq)
        if (x,y) == goal: break
        for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:
            nx, ny = x+dx, y+dy
            if 0<=nx<len(grid) and 0<=ny<len(grid) and grid[nx][ny]==0:
                new_cost = d + 1
                if (nx,ny) not in dist or new_cost < dist[(nx,ny)]:
                    dist[(nx,ny)] = new_cost
                    visited[(nx,ny)] = (x,y)
                    heapq.heappush(pq, (new_cost, (nx,ny)))

    return reconstruct_path(visited, goal)

def heuristic(a, b):
    return abs(a[0]-b[0]) + abs(a[1]-b[1])

def astar(grid, start, goal):
    open_set = [(0, start)]
    came_from = {start: None}
    g = {start: 0}

    while open_set:
        _, current = heapq.heappop(open_set)
        if current == goal: break
        x, y = current
        for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:
            nx, ny = x+dx, y+dy
            if 0<=nx<len(grid) and 0<=ny<len(grid) and grid[nx][ny]==0:
                tentative = g[current] + 1
                if (nx,ny) not in g or tentative < g[(nx,ny)]:
                    g[(nx,ny)] = tentative
                    f = tentative + heuristic((nx,ny), goal)
                    came_from[(nx,ny)] = current
                    heapq.heappush(open_set, (f, (nx,ny)))

    return reconstruct_path(came_from, goal)

def reconstruct_path(parent, goal):
    if goal not in parent:
        return []
    cur, path = goal, []
    while cur is not None:
        path.append(cur)
        cur = parent[cur]
    return list(reversed(path))

def benchmark(algorithm, grid, start, goal):
    tracemalloc.start()
    t0 = time.time()
    path = algorithm(grid, start, goal)
    runtime = time.time() - t0
    mem = tracemalloc.get_traced_memory()[1]
    tracemalloc.stop()
    return runtime, mem, path


if __name__ == "__main__":
    sizes = [10, 20, 40]
    algorithms = {
        "BFS": bfs,
        "DFS": dfs,
        "Dijkstra": dijkstra,
        "A* Search": astar
    }

    for n in sizes:
        print("="*60)
        print(f"Testing Grid {n}x{n}")
        grid = generate_grid(n)
        start, goal = (0,0), (n-1,n-1)

        for name, algo in algorithms.items():
            runtime, mem, path = benchmark(algo, grid, start, goal)
            print(f"{name:<12} Runtime: {runtime:.6f}s  | Memory: {mem/1024:.2f}KB  | Path length: {len(path)}")
        print()
